#!/usr/bin/env python3
"""
generate_river_connections.py

Reads data/rivers/ireland_rivers.geojson and src/data/provinces.json,
then derives province-to-province river connections by mapping each river
coordinate to the nearest Ireland province.

Outputs src/data/river_connections.json with:
  - connections: list of {from_id, to_id, river_name} pairs
  - province_rivers: map from province_id -> [river_name, ...]

Usage:
    python3 generate_river_connections.py
"""

import json
import math
import os
from typing import Any

REPO_ROOT = os.path.dirname(os.path.abspath(__file__))
RIVERS_GEOJSON = os.path.join(REPO_ROOT, "data", "rivers", "ireland_rivers.geojson")
PROVINCES_JSON = os.path.join(REPO_ROOT, "src", "data", "provinces.json")
OUTPUT_JSON    = os.path.join(REPO_ROOT, "src", "data", "river_connections.json")

# Only create a connection if the two provinces are within this many hex-steps.
# Prevents spurious long-range connections when river coordinates jump across
# large gaps in province coverage.
MAX_HEX_DIST = 4

def haversine_km(lat1: float, lng1: float, lat2: float, lng2: float) -> float:
    """Great-circle distance in km between two lat/lng points."""
    R = 6371.0
    dlat = math.radians(lat2 - lat1)
    dlng = math.radians(lng2 - lng1)
    a = math.sin(dlat / 2) ** 2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlng / 2) ** 2
    return R * 2 * math.asin(math.sqrt(a))


def nearest_ireland_province(lat: float, lng: float, provinces: list[dict[str, Any]]) -> dict[str, Any] | None:
    """Return the Ireland province whose lat/lng is closest to (lat, lng)."""
    best = None
    best_dist = float("inf")
    for p in provinces:
        plat = p.get("lat")
        plng = p.get("lng")
        if plat is None or plng is None:
            continue
        d = haversine_km(lat, lng, plat, plng)
        if d < best_dist:
            best_dist = d
            best = p
    return best


def hex_distance(p1: dict, p2: dict) -> int:
    """Axial hex-grid distance between two provinces using their x,y coords."""
    dx = p1["x"] - p2["x"]
    dy = p1["y"] - p2["y"]
    return (abs(dx) + abs(dy) + abs(dx + dy)) // 2


def main() -> None:
    # Load provinces and filter to Ireland only
    with open(PROVINCES_JSON) as f:
        all_provinces: list[dict[str, Any]] = json.load(f)
    ireland_provinces = [p for p in all_provinces if p["id"].startswith("ireland_")]
    print(f"Loaded {len(ireland_provinces)} Ireland provinces")

    # Load river GeoJSON
    with open(RIVERS_GEOJSON) as f:
        rivers_geojson: dict[str, Any] = json.load(f)

    connections: list[dict[str, str]] = []
    province_rivers: dict[str, list[str]] = {}

    seen_connections: set[tuple[str, str]] = set()

    for feature in rivers_geojson["features"]:
        river_name: str = feature["properties"]["name"]
        coords: list[list[float]] = feature["geometry"]["coordinates"]

        print(f"\nProcessing {river_name} ({len(coords)} points)...")

        prev_province: dict[str, Any] | None = None

        for lng, lat in coords:
            province = nearest_ireland_province(lat, lng, ireland_provinces)
            if province is None:
                continue

            pid = province["id"]

            # Record that this river touches this province
            if pid not in province_rivers:
                province_rivers[pid] = []
            if river_name not in province_rivers[pid]:
                province_rivers[pid].append(river_name)

            # Create connection if the nearest province changed
            if prev_province is not None and prev_province["id"] != pid:
                # Guard against very long jumps (e.g. sparse coords spanning many hexes)
                hex_dist = hex_distance(prev_province, province)
                if hex_dist <= MAX_HEX_DIST:
                    key = tuple(sorted([prev_province["id"], pid]))
                    if key not in seen_connections:
                        seen_connections.add(key)
                        connections.append({
                            "from_id": key[0],
                            "to_id": key[1],
                            "river_name": river_name,
                        })
                        print(f"  Connect: {prev_province['name']} ({prev_province['id']}) "
                              f"<-> {province['name']} ({pid})  [dist={hex_dist}]")
                else:
                    print(f"  SKIP long jump ({hex_dist} hexes): "
                          f"{prev_province['name']} -> {province['name']}")

            prev_province = province

    print(f"\n=== Summary ===")
    print(f"River connections: {len(connections)}")
    print(f"Provinces with rivers: {len(province_rivers)}")

    output = {
        "_comment": (
            "Auto-generated by generate_river_connections.py from "
            "data/rivers/ireland_rivers.geojson. Do not edit manually. "
            "Re-run generate_river_connections.py to regenerate."
        ),
        "connections": connections,
        "province_rivers": province_rivers,
    }

    with open(OUTPUT_JSON, "w") as f:
        json.dump(output, f, indent=2)
    print(f"Written to {OUTPUT_JSON}")


if __name__ == "__main__":
    main()
